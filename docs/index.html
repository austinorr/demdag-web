<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DEMDAG</title>
    <script id="vertex-shader-2d" type="x-shader/x-vertex">
      attribute vec2 a_position;
      attribute vec2 a_texCoord;

      uniform vec2 u_resolution;

      varying vec2 v_texCoord;

      void main() {
        // convert the rectangle from pixels to 0.0 to 1.0
        vec2 zeroToOne = a_position / u_resolution;

        // convert from 0->1 to 0->2
        vec2 zeroToTwo = zeroToOne * 2.0;

        // convert from 0->2 to -1->+1 (clipspace)
        vec2 clipSpace = zeroToTwo - 1.0;

        gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);


        // pass the texCoord to the fragment shader
        // The GPU will interpolate this value between points.
        v_texCoord = a_texCoord;
      }
    </script>

    <!-- fragment shader -->
    <script id="fragment-shader-2d" type="x-shader/x-fragment">
      precision highp float;
      precision highp int;

      uniform vec2 u_resolution;
      uniform vec2 u_mouse;
      uniform float u_zoom;
      uniform float u_isSnap;

      // our textures
      uniform sampler2D u_image0;
      uniform sampler2D u_image1;
      uniform sampler2D u_image2;

      // the texCoords passed in from the vertex shader.
      varying vec2 v_texCoord;

      int buildInt(vec4 rgba) {
        int dv = int(rgba.r * 256.0) + int(rgba.g * 256.0 * 256.0) + int(rgba.b * 256.0 * 65536.0) + int(rgba.a * 256.0 * 16777216.0);
        return dv;
      }

      vec2 pos_maxacc_9() {
        vec2 mpos = u_mouse / u_resolution;
        int maxacc = 0;
        for (float i = -1.0; i <= 1.0; i += 1.0) {
            for (float j = -1.0; j <= 1.0; j += 1.0) {
              // Shader operations
              vec2 delta = vec2(i, j);
              vec2 newpos = (u_mouse + delta) / u_resolution ;

              vec4 newdvec = texture2D(u_image0, newpos);
              int newdv = buildInt(newdvec);

              vec4 newfvec = texture2D(u_image1, newpos);
              int newfv = buildInt(newfvec);

              int acc = newfv - newdv;

              if (acc > maxacc) {
                maxacc = acc;
                mpos = newpos;
              }
          }
        }

        return mpos;

      }

      vec2 pos_maxacc_25() {
        vec2 mpos = u_mouse / u_resolution;
        int maxacc = 0;
        for (float i = -2.0; i <= 2.0; i += 1.0) {
            for (float j = -2.0; j <= 2.0; j += 1.0) {
              // Shader operations
              vec2 delta = vec2(i, j);
              vec2 newpos = (u_mouse + delta) / u_resolution ;

              vec4 newdvec = texture2D(u_image0, newpos);
              int newdv = buildInt(newdvec);

              vec4 newfvec = texture2D(u_image1, newpos);
              int newfv = buildInt(newfvec);

              int acc = newfv - newdv;

              if (acc > maxacc) {
                maxacc = acc;
                mpos = newpos;
              }
          }
        }

        return mpos;

      }

      vec2 pos_maxacc_81() {
        vec2 mpos = u_mouse / u_resolution;
        int maxacc = 0;
        for (float i = -4.0; i <= 4.0; i += 1.0) {
            for (float j = -4.0; j <= 4.0; j += 1.0) {
              // Shader operations
              vec2 delta = vec2(i, j);
              vec2 newpos = (u_mouse + delta) / u_resolution ;

              vec4 newdvec = texture2D(u_image0, newpos);
              int newdv = buildInt(newdvec);

              vec4 newfvec = texture2D(u_image1, newpos);
              int newfv = buildInt(newfvec);

              int acc = newfv - newdv;

              if (acc > maxacc) {
                maxacc = acc;
                mpos = newpos;
              }
          }
        }

        return mpos;

      }

      vec2 pos_maxacc_289() {
        vec2 mpos = u_mouse / u_resolution;
        int maxacc = 0;
        for (float i = -8.0; i <= 8.0; i += 1.0) {
            for (float j = -8.0; j <= 8.0; j += 1.0) {
              // Shader operations
              vec2 delta = vec2(i, j);
              vec2 newpos = (u_mouse + delta) / u_resolution ;

              vec4 newdvec = texture2D(u_image0, newpos);
              int newdv = buildInt(newdvec);

              vec4 newfvec = texture2D(u_image1, newpos);
              int newfv = buildInt(newfvec);

              int acc = newfv - newdv;

              if (acc > maxacc) {
                maxacc = acc;
                mpos = newpos;
              }
          }
        }

        return mpos;

      }

      vec2 get_mpos() {

        if (u_isSnap <= 0.5) {
          return u_mouse / u_resolution;
        }

        if (u_zoom >= 4.0) {
          return u_mouse / u_resolution;
        }

        if (u_zoom >= 2.0) {
          return pos_maxacc_9();
        }

        if (u_zoom >= 1.0) {
          return pos_maxacc_25();
        }

        if (u_zoom >= 0.5) {
          return pos_maxacc_81();
        }

        if (u_zoom <= 0.25) {
          return pos_maxacc_289();
        }

        return u_mouse / u_resolution;
      }

      void main() {

        vec2 mpos = get_mpos();

        vec4 dvec = texture2D(u_image0, mpos);
        vec4 fvec = texture2D(u_image1, mpos);

        int dv = buildInt(dvec);
        int fv = buildInt(fvec);

        vec4 color0 = texture2D(u_image0, v_texCoord);
        vec4 color1 = texture2D(u_image1, v_texCoord);

        int d = buildInt(color0);
        int f = buildInt(color1);

        gl_FragColor = texture2D(u_image2, v_texCoord);

        // trace downstream flow path
        if (d < dv && f >= fv) {
          // boost to yellow.
          gl_FragColor += vec4(1.0, 1.0, 0.0, 0.0);
        }

        // trace upstream watershed
        if (d >= dv && f <= fv) {
          gl_FragColor *= vec4(0.1, 0.5, 0.8, 1.0);

          // boost blue channel to pure blue so we can count it up.
          gl_FragColor += vec4(0.0, 0.0, 1.0, 0.0);
        }

        // draw the loupe
        vec2 ss = vec2(gl_FragCoord.x, u_resolution.y - gl_FragCoord.y);
        float mdist = distance(floor(u_mouse) + vec2(0.5, 0.5), ss) * min(u_zoom, 1.0);
        if (mdist < 1.41422 * 1.8 && (mdist > 1.41422 * 1.2 || mdist <= 0.6)) {
          gl_FragColor *= vec4(0.2, 0.2, 0.2, 1.0);
        }
      }
    </script>
    <style>
      #area-units div {
        margin: 0em 0.25em;
        width: 6ch;
        display: flex;
        border-radius: 0.5em;
      }
      #area-units div:not(input:checked) {
        border: 2px solid rgba(255, 255, 255, 255);
        background-color: rgb(228, 228, 228);
        font-weight: bold;
      }
      #area-units div:has(input:checked),
      button.checked {
        background-color: rgb(110, 180, 255);
        font-weight: bold;
        border: 2px solid;
        border-color: rgb(110, 180, 255);
      }
      #area-units input {
        display: none;
      }
      #area-units label {
        padding: 0.25em 0.25em;
        text-align: center;
        width: 100%;
        font-size: small;
      }
      #area-units,
      button {
        font-family: sans-serif;
      }
      #nav-zoom button {
        border-radius: 0.5em;
        margin: 2px;
      }
      #nav-zoom > button {
        margin: 3px;
      }
    </style>
    <script type="module" crossorigin src="/demdag-web/assets/index-D5ycldIV.js"></script>
  </head>
  <body>
    <div
      style="
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
      "
    >
      <div style="text-align: center">
        Hover over the image (or touch) to see the complete watershed
        delineation upstream of each pixel.<br />On mobile devices, use two
        fingers to pan.
      </div>
      <div id="nav-zoom" style="display: flex; margin-top: 1rem">
        <button onclick="main('sm')">Mini Map</button>
        <button onclick="main('lg')">St. Helens</button>
        <button
          style="
            pointer-events: none;
            background-color: rgba(255, 255, 255, 0);
            border: none;
          "
        >
          Zoom:&nbsp;<span
            id="zoom"
            style="width: 3ch; font-weight: bold"
          ></span>
        </button>
        <div id="zoom-buttons" style="display: flex; flex-direction: column">
          <button onclick="adjustZoom(1)" style="width: 5ch">+</button>
          <button onclick="adjustZoom(-1)" style="width: 5ch">-</button>
        </div>
        <button id="enableSnap" class="checked">Snap</button>
      </div>
      <div id="area-units" style="display: flex; margin: 1rem"></div>
      <div
        id="area-summary"
        style="
          position: fixed;
          pointer-events: none;
          background-color: rgba(255, 255, 255, 0.6);
          padding: 0.2em;
          border-radius: 0.25em;
          font-size: 8pt;
        "
      >
        <table>
          <tr id="area_row">
            <td style="text-align: right">Area:</td>
            <td><span id="area_value"></span></td>
          </tr>
        </table>
      </div>
      <div style="display: flex; width: 100%">
        <div style="margin: auto">
          <canvas id="canvas" style="image-rendering: pixelated"></canvas>
        </div>
      </div>
    </div>
  </body>
</html>
